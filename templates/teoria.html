<!DOCTYPE html>
<html lang="en">
<head>		
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="true">
    <meta name = "format-detection" content = "telephone=no">
        
    <title>RGROpros-Teoria</title>
    <style>
        body{
        margin: 0px;
        background-color: #36393f;
        font-family: 'Roboto', sans-serif;
        font-size: 18px;
        color: #fff;
    }
    header{
        background-color: #2d2f33;
    }
    p,ol,li {
        margin: 0 auto;
        max-width: 60%;
        padding-top: 1.4em;
        /* font-family: sans-serif; */
        
    }
    table{
        max-width: 4em;
    }
    li{
        font-style:italic;
        margin-left: 3.5%;
        margin-top: 2px;
        
    }
    h1, h3 {
        padding-top: 1.5em;
        /* font-family: sans-serif; */
    }
    h1 {
        font-size: 32px;
    }
    table, td, tr{
        border: 1px solid black;
        
    }
    
    figcaption{
        font-style:italic;
    }
    figure{
        float: right;
        margin: 20px;
    }
    button{
        background-color: #5865f2;
        border: none;
        display: block;
        width: 100%;
        cursor: pointer;
        font-size: 20px;
        font-weight: bold;
        text-transform: uppercase;
        color: #fff;
        padding: 15px;
        transition: all 0.5s ease;
        border-radius: 20px;
    }
    button:hover{
        background-color: #707bf5;
    }
    button:focus{
        outline: none;
        background-color: #5865f2;
    }
    table {
        margin: 0 auto;
        max-width: 60%; 
        border-color: #fff;
        border-radius: 2px;
    }
    th, td {
        border: 2px solid #fff;
        
    }
    img{
        padding-top: 20px;
        margin: auto;
        max-width: 700px;
        max-height: 700px;
        display: block;
    }
    .Back{
        margin-top: 0em;
        margin-bottom: 0em;
        bottom:90px;
        width:15%;
        margin-left:2%;
        padding:32px 12px 4px;
    }
    </style>
	<!-- Styles -->
    <!-- <link rel="stylesheet"  href="ter.css" /> -->

</head>
<body>
    <header>
    <div class="Back">
        <button id ="BackToTest">Назад</button>
</header>

<p>OSPF (Open Shortest Path First) &mdash; протокол динамической маршрутизации, основанный на технологии отслеживания состояния канала (link-state technology) и использующий для нахождения кратчайшего пути алгоритм Дейкстры.</p>
<p>Протокол маршрутизации OSPF (Open Shortest Path First) представляет собой открытый (Open) протокол состояния связей, использующий алгоритм SPF поиска кратчайшего пути на графе. Применяется для внутренней маршрутизации в сетях любой сложности.</p>
<ol> OSPF предлагает решение следующих задач:
    <li>увеличение скорости сходимости</li>
    <li> поддержка сетевых масок переменной длины (Variable Length Subnet Masking, VLSM,);</li>
    <li>достижимость сети (быстро обнаруживаются отказавшие маршрутизаторы);&nbsp;</li>
    <li>оптимальное использование пропускной способности;&nbsp;</li>
    <li>динамическое перераспределение трафика между параллельными каналами, которое выполняется пропорционально степени загруженности этих каналов;</li>
    <li>метод выбора пути.&nbsp;</li>
</ol>

<ol> Преимущество протокола OSPF:
    <li>отсутствуют ограничения на размер сети, используется иерархическая структура сети, что позволяет существенно повысить эффективность использования каналов передачи данных за счет сокращения доли передаваемого по ним служебного трафика;</li>
    <li>обеспечивает несколько маршрутов в сторону одного узла;</li>
    <li> обеспечивает аутентификацию;</li>
    <li>обеспечивает поддержку внеклассовых сетей;</li>
    <li>обеспечивает передачу обновлений маршрутов с использованием адресов типа multicast;</li>
    <li>обеспечивает достаточно большую скорость установления маршрута;</li>
    <li>обеспечивает использование процедуры аутентификации при передаче и получении обновлений маршрутов.</li>
</ol>

<ol>Основные особенности протокола:
    <li>каждому каналу может быть присвоен свой вес (количество ретрансляций). Ограничение на количество ретрансляций (&laquo;хопов&raquo;) &mdash; 65 535;</li>
    <li>каждый узел содержит базу сетевых путей в виде дерева, в вершине которого находится данный узел;</li>
    <li> если существуют пути с одинаковым весом, нагрузка распределяется между ними (режим баланса нагрузки);</li>
    <li>широковещательная рассылка таблиц маршрутизации производится только при появлении изменений;</li>
    <li>сообщения об изменениях в таблице маршрутизации отправляются только тем маршрутизаторам, которые непосредственно связаны с ним. Метод &laquo;прочти сам и передай дальше&raquo; уменьшает нагрузку на сеть&nbsp;</li>
</ol>
<p>Так как OSPF реализован в качестве единственного протокола маршрутизации в сети (однородная маршрутизирующая система&raquo;), где каждый маршрутизатор поддерживает свою собственную таблицу маршрутизации, поэтому он должен хранить информацию только о непосредственно подключенных к нему подсетях и тех маршрутизаторах, которые ему непосредственно доступны (так называемых смежных маршрутизаторах).</p>
<p>Процесс построения таблиц маршрутизации разбит на два этапа.</p>
<p>1-й этап. Каждый маршрутизатор строит граф связей сети. Для этого все маршрутизаторы обмениваются сообщениями со своими соседями объявлениями о состоянии связей. При этом маршрутизаторы ее не модифицируют, а передают в неизменном виде. В результате все маршрутизаторы обладают идентичными сведениями о графе сети, которые хранятся в базе данных о топологии сети.&nbsp;</p>
<p>2-й этап. Нахождение оптимальных маршрутов на основе итерационного алгоритма Дейкстры. В каждом найденном маршруте запоминается один шаг &mdash; до следующего маршрутизатора, эта информация попадает в таблицу маршрутизации. Если несколько маршрутов имеют одну и ту же метрику &mdash; запоминаются первые шаги для всех этих маршрутов&nbsp;</p>
<p>Для контроля состояния связей маршрутизаторы передают друг
    другу каждые 10 секунд короткие сообщения HELLO</p>
    <img src="https://sun1-83.userapi.com/s/v1/if2/EMBjQUqFu4WnMan8HbRiie-5LUCM-lMBRwjuNZlL6vf-lVNHN_aqB5yGygMVlmpioUwspvuJUcYILzUwauL9CLVU.jpg?size=1272x672&quality=96&type=album" alt="Контроль состояния связей">
<p>Таким образом, тестируется состояние линий. Если в течение определенного периода сообщения от какого-то маршрутизаторасоседа перестают поступать — данный маршрутизатор делает вывод
    о неработоспособном состоянии связи, корректирует свои базы данных и шлет объявления об изменении состояния линий своим непосредственным соседям. Те тоже корректируют свои базы данных и
    пересылают информацию дальше.</p>
<p>Аналогичная процедура происходит, если появляется новый сосед
    и заявляет о себе сообщением HELLO.
    </p>
<p>Если состояние сети не меняется — объявления о связях не генерируются, что экономит пропускную способность сети и вычислительные ресурсы маршрутизаторов.</p>        
<p>Каждые 30 минут все маршрутизаторы обмениваются всеми записями базы данных о топологии сети с целью синхронизации для
    более надежной работы.</p>
<p>Для сбора маршрутной информации протокол OSPF использует извещения состояния канала (LSA, link-state advertisement), топологическую базу данных, алгоритм SPF, результирующее SPF-дерево и таблицу маршрутизации путей и портов в каждую сеть.&nbsp;</p>
<ol>Метрика представляет собой оценку качества связи в данной сети (на данном физическом канале). Метрика учитывает следующие параметры:
    <li>
        пропускную способность канала;
    </li>
    <li>
        величину задержки распространения сигнала в канале;
    </li>
    <li>
        надежность канала;
    </li>
    <li>
        загруженность канала;
    </li>
    <li>
        размер максимального блока данных, который может быть передан через данный канал.
    </li>
</ol>
<p>Чем меньше метрика, тем выше качество соединения. Метрика
    маршрута равна сумме метрик всех связей (сетей), входящих в маршрут. В простейшем случае метрика каждой сети равна единице, тогда
    метрика маршрута является его длиной, определяемой количеством
    шагов до станции назначения (т.е. количеством маршрутизаторов, через которые будет проходить путь). При использовании алгоритма
    SPF ситуации, приводящие к счету до бесконечности, отсутствуют.
    Значения метрик могут варьироваться в широком диапазоне. Протокол OSPF позволяет назначить для любой сети различные значения
    метрик в зависимости от типа сервиса. (Тип сервиса запрашивается
    дейтаграммой в соответствии со значением поля TOS ее заголовка).
    </p> 
<p>Для каждого типа сервиса будет вычисляться свой маршрут, и
    дейтаграммы, затребовавшие наиболее скоростной канал, могут быть
    отправлены по одному маршруту, а затребовавшие менее скоростной
    канал — по-другому. Метрика пути, оценивающая пропускную способность, определяется как количество секунд, требуемое для передачи через физическую среду данной сети. Порядок расчета метрик,
    оценивающих надежность, задержку и стоимость, не определен. Администратор, желающий поддерживать маршрутизацию по этим типам сервисов, сам назначает разумные и согласованные метрики по
    этим параметрам. Если не требуется маршрутизация с учетом типа сервиса (или маршрутизатор ее не поддерживает), используется метрика по умолчанию, равная метрике по пропускной способности.
</p>
<img src="https://i.ibb.co/qjrwS2F/image.png" alt="Построение топологической базы">
<p>Построение топологической базы</p>
<p>Дадим краткое описание работы протокола на основе алгоритма
    SPF. Маршрутизаторы обмениваются hello-пакетами через все интерфейсы, на которых активирован OSPF. Маршрутизаторы, разделяющие общий канал передачи данных становятся соседями, когда они
    приходят к договоренности об определенных параметрах, указанных
    в их hello-пакетах.</p>
    <ol>
        <li>
            Пара маршрутизаторов, находящихся в состоянии соседства, синхронизирует между собой базу данных состояния каналов;
        </li>
        <li>
            Каждый маршрутизатор, используя LSA, строит топологическую базу данных состояния каналов (топологическую таблицу), которая является картиной связи маршрутизаторов в одной области, обновляет ее и передает LSA всем соседним устройствам. Маршрутизаторы внутри одной области обладают общей информацией, у них
одинаковые топологические базы данных.
Канал — это линия связи или интерфейс, соединяющий один
маршрутизатор с другим или с сетью. Состояние канала — это описание интерфейса и его связей с соседними маршрутизаторами. Описание интерфейса может включать, например, IP-адрес интерфейса,
маску, тип сети, к которой он подключен. Набор всех этих состояний
каналов формирует базу данных состояния каналов
        </li>
        <li>
            Как только маршрутизаторы OSPF соберут информацию о состоянии каналов, они начинают вычислять кратчайший путь к каждой
            сети на основе метрик. Каждый маршрутизатор считает себя корнем
            дерева и, используя базу данных состояний каналов, вычисляет наилучшие пути к сетям назначения, применяя алгоритм SPF (алгоритм
            Дейкстры) и выстраивая при этом SPF-дерево, основываясь на суммарной стоимости маршрута, который используется для достижения
            этих сетей. Данный процесс может обнаруживать изменения в сетевой топологии, вызванные отказами оборудования и ростом сети.
            Каждый маршрутизатор будет иметь свой собственный взгляд на
            топологию, несмотря на то, что все маршрутизаторы будут строить
            дерево кратчайших путей, используя одну и ту же базу данных состояния каналов
        </li>
        <li>
            Затем из этого дерева к сетям назначения выбираются пути с
наименьшей стоимостью (метрикой) и помещаются в таблицу маршрутизации. Метрика интерфейса — это индикатор усилий, которые
необходимы для отправки пакета через этот интерфейс. Метрика интерфейса обратно пропорциональна полосе пропускания интерфейса,
таким образом, большая полоса пропускания соответствует меньшей
метрике.
        </li>
        <img src="https://i.ibb.co/4Y9SnQy/2022-05-21-15-46-34-vk-com-3dadbb3aace5.png" alt="Выбираются пути с наименьшей стоимостью">
        <p>Выбираются пути с наименьшей стоимостью</p>
        <li>После первоначального построения таблицы маршрутизации
            необходимо отслеживать изменения состояния сети и вносить коррективы в таблицу маршрутизации. Для контроля состояния связей и
            соседних маршрутизаторов они передают специальные короткие сообщения HELLO. Если состояние сети не меняется, то маршрутизаторы
            корректировкой своих таблиц маршрутизации не занимаются и не
            посылают соседям объявления о связях. Сообщения HELLO отправляются через каждые 10 секунд, чтобы повысить скорость адаптации
            маршрутизаторов к изменениям, происходящим в сети. Небольшой
            объем этих сообщений делает возможной такое частое тестирование
            состояния соседей и связей с ними.</li>
    </ol>
    <img src="https://i.ibb.co/PWxmx5k/2022-05-21-14-58-02-vk-com-1f809b5660bf.png" alt="Состояние канала и назначение метрик">
    <p>             Состояние канала и назначение метрик</p>
    <img src="https://i.ibb.co/vVpZN4v/2022-05-21-15-14-00-vk-com-cb4e50a152c8.png" alt="Свой собственный взгляд на топологию со стороны
    маршрутизаторов">
    <p>Свой собственный взгляд на топологию со стороны
        маршрутизаторов </p>
    <p>В нашем примере мы будем использовать метрики, без учета типов сервиса. Следует заметить, что маршрутизация по типам сервиса редко используется, более того, она исключена
        из последних версий стандарта OSPF.</p>
     <p>Для работы алгоритма SPF на каждом маршрутизаторе, как уже
            говорилось ранее, создается база данных состояния связей, представляющая собой полное описание графа OSPF-системы. При этом вершинами графа являются маршрутизаторы, а ребрами — соединяющие
            их связи. Базы данных на всех маршрутизаторах одинаковы.</p>
    <p>База данных состояния связей представляет из себя таблицу,
        где для каждой пары смежных вершин графа (маршрутизаторов) указано ребро (связь), их соединяющее, и метрика этого ребра. База
        данных состояния связей в нашем примере выглядит, как показано в
        таблице</p>
        <table class="iksweb">
            <tbody>
                <tr>
                    <td>От → до</td>
                    <td>шаг</td>
                    <td>Метрика (стоимость)</td>
                </tr>
                <tr>
                    <td>R1 → R2</td>
                    <td>1</td>
                    <td>20</td>
                </tr>
                <tr>
                    <td>R1 → R3</td>
                    <td>1</td>
                    <td>40</td>
                </tr>
                <tr>
                    <td>R1 → R4</td>
                    <td>1</td>
                    <td>20</td>
                </tr>
                <tr>
                    <td>R2 → R5 </td>
                    <td>1</td>
                    <td>10</td>
                </tr>
                <tr>
                    <td>R3 → R5</td>
                    <td>1</td>
                    <td>10</td>
                </tr>
                <tr>
                    <td>R4 → R5</td>
                    <td>1</td>
                    <td>20</td>
                </tr>
                <tr>
                    <td>R1 → R2 → R5</td>
                    <td>2</td>
                    <td>30
        </td>
                </tr>
                <tr>
                    <td>R1 → R4 → R5</td>
                    <td>2</td>
                    <td>40</td>
                </tr>
                <tr>
                    <td>R1 → R3 → R5 </td>
                    <td>2</td>
                    <td>50
        </td>
                </tr>
                <tr>
                    <td>R1 → R2 → R5 → R3</td>
                    <td>3</td>
                    <td>40</td>
                </tr>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
            </tbody>
        </table>
        <p>Алгоритм SPF, основываясь на базе данных состояния связей,
            вычисляет кратчайшие пути между маршрутизаторами. Результатом
            работы алгоритма является таблица, где для каждой вершины графа
            указан список ребер, соединяющих маршрутизаторы между собой по
            кратчайшему пути.</p>
        <p>Поддержка множественных маршрутов (multipath). Если
                между двумя узлами сети существует несколько маршрутов с одинаковыми или близкими по значению метриками, протокол OSPF позволяет направить часть трафика по этим маршрутам в пропорции,
                соответствующей значениям метрик. Например, если существует два
                альтернативных маршрута с метриками 1 и 2, то две трети трафика будет направлено по первому из них, а оставшаяся треть — по
                второму</p>      
        <p>Положительный эффект от использования такого механизма заключается в уменьшении средней задержки прохождения дейтаграмм
            между отправителем и получателем, а также в уменьшении колебаний значения средней задержки. Менее очевидное преимущество поддержки множественных маршрутов состоит в следующем. Если при
            использовании только одного из возможных маршрутов этот маршрут
            внезапно выходит из строя, весь трафик будет разом перемаршрутизирован на альтернативный маршрут, при этом во время процесса
            массового переключения больших объемов трафика с одного маршрута на другой весьма велика вероятность образования затора на новом
            маршруте. Если же до аварии использовалось разделение трафика по
            нескольким маршрутам, отказ одного из них вызовет перемаршрутизацию лишь части трафика, что существенно сгладит нежелательные
            эффекты</p>  
<p>OSPF-заголовок. Размер OSPF-сообщения ограничен максимальным размером дейтаграммы. Все сообщения OSPF имеют общий заголовок, следующий в дейтаграмме непосредственно за IP заголовком</p>
<table style="border-collapse: collapse;" border="1">
<tbody>
<tr>
<td style="width: 25%; text-align: right;">0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7</td>
<td style="width: 25%; text-align: right;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15</td>
<td style="width: 25.142%; text-align: right;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;23</td>
<td style="width: 24.858%; text-align: right;">24&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;31</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">Версия</td>
<td style="width: 25%; text-align: center;">Тип сообщения</td>
<td style="width: 50%; text-align: center;" colspan="2">Длина сообщения</td>
</tr>
<tr>
<td style="width: 100%; text-align: center;" colspan="4">Идентификатор маршрутизатора</td>
</tr>
<tr>
<td style="width: 100%; text-align: center;" colspan="4">Идентификатор области</td>
</tr>
<tr>
<td style="text-align: center; width: 50%;" colspan="2">Контрольная сумма</td>
<td style="text-align: center; width: 50%;" colspan="2">Аутентификация сообщения</td>
</tr>
<tr>
<td style="width: 100%; text-align: center;" colspan="4">Аутентификационные данные</td>
</tr>
</tbody>
</table>
<ol>Поле «Версия» (1 байт) — версия протокола.
    Поле «Тип сообщения» (1 байт). Применяются следующие типы
    сообщений:
    <li>hello — используется для «знакомства» с соседями;</li>
    <li>описание базы данных (Database Description) — сообщает о
        том, насколько свежей информацией располагает отправитель;</li>
    <li>запрос состояния связей (Link State Request) — запрашивает
        информацию у партнера;</li>
    <li>обновление состояния связей (Link State Update) — сообщает
        соседям информацию о связях отправителя;</li>
    <li>подтверждение приема сообщения о состоянии связей (Link
        State Acknowledgment) — подтверждает обновление состояния
        связей.
        </li>
</ol>
<p>
    «Длина сообщения», включая заголовок, составляет 2 байта.
</p>
<p>«Идентификатор маршрутизатора», отправившего сообщение
    (4 байта), равен адресу одного из IP-интерфейсов маршрутизатора</p>
    <p>«Идентификатор области», к которой относится данное сообщение (4 байта), — номер 0 зарезервирован для магистрали. Часто идентификатор области полагают равным адресу IP-сети (одной из
        IP-сетей) этой области.</p>
    <p>«Контрольная сумма» (2 байта) — охватывает все OSPF-сообщение, включая заголовок, но исключая поле «аутентификационные
        данные»; вычисляется по тому же алгоритму, что и в IP-заголовке</p>
<p>«Аутентификации сообщения» (2 байта). Стандарт определяет
    несколько возможных типов, самые простые из них: 0 — нет аутентификации, 1 — аутентификация с помощью пароля.</p> 
<p>«Аутентификационные данные» (может быть от 4 до 7 байт) —
    например, 8-символьный пароль.</p>
<p>Каждый маршрутизатор самостоятельно производит выборы выделенного и запасного выделенного маршрутизаторов на основании
    имеющихся у него данных о соседях и о том, кого каждый из соседей назначил на эту роль. Фактически процесс выборов происходит
    постоянно, после получения каждого Hello-сообщения, но алгоритм
    гарантирует, что при стабильном состоянии сети всеми маршрутизаторами будут выбираться одни и те же идентификаторы выделенного
    маршрутизатора (Designated Router, DR) и идентификаторы запасного
    выделенного маршрутизатора (Backup Designated Router, BDR).</p>
<p>Каждый маршрутизатор может объявить себя либо выделенным,
    либо запасным, поместив свой идентификатор в соответствующее поле своих Hello-сообщений. Иначе он может поместить туда адреса
    других маршрутизаторов, если он считает их занимающими соответствующие роли. Если маршрутизатор не определился с выбором DR
    и/или BDR (например, после включения), он заполняет соответствующие поля нулями.
    </p>    
<p>Выбор проводится только среди соседей, с которыми установлена
    двусторонняя связь и приоритет которых не равен нулю; в этот список
    маршрутизатор включает и себя, если его приоритет не нулевой.</p>
    <p>

    </p>    
<!-- Scripts -->
<!-- <script src="ter.js"></script> -->
<script>
    BackToTest.addEventListener('click', () => {
    window.location.href = 'test.html';
});
</script>
</body>
</html>